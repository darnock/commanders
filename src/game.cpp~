#include <ctime>
#include <SDL2/SDL_ttf.h>
#include <stdlib.h>
#include <fstream>
#include <iostream>
#include <string>
#include "include/game.h"
#include "include/game_settings.h"
#include "include/units.h"
#include "include/text.h"
#include "include/sign.h"
//uncomment to turn off assert functions
#define NDEBUG
#include <assert.h>
#include <vector>
#include <sstream>

Uint32 * pixels = NULL;
szeregowy zolnierze[ILEOBJ]; //deklaracja ILEOBJ ludzi

char return_value=0;

void Game::init(){
    // game state set to runing
    quit = false;
    // left mouse buton click set to false
    leftMouseButtonDown = false;
    // init SDL
    SDL_Init(SDL_INIT_EVERYTHING);
    // init ttf
    TTF_Init();
    srand( time( NULL ) );
    
    // read settings
    read_settings();
    
    pixels =  new Uint32[get_width() * get_height()];
    
    // creat window
    window = SDL_CreateWindow("MISA v0.1b",
        SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, get_width(), get_height(), 0);

    renderer = SDL_CreateRenderer(window, -1, 0);
    texture = SDL_CreateTexture(renderer,
        SDL_PIXELFORMAT_ARGB8888, SDL_TEXTUREACCESS_STATIC, get_width(), get_height());
//    memset(pixels, 0, XRES * YRES * sizeof(Uint32));

    for(int x=0; x<ILEOBJ; x++) zolnierze[x].init(rand()%(get_width()-1),rand()%(get_height()-1),0x00ff00);
}
void Game::handleEvents(){
 	while(SDL_PollEvent(&event) > 0)
	{
		//SDL_WaitEvent(&event);
	 
		switch (event.type)
		{
		case SDL_MOUSEBUTTONUP:
		    if (event.button.button == SDL_BUTTON_LEFT)
		        leftMouseButtonDown = false;
		    break;
		case SDL_MOUSEBUTTONDOWN:
		    if (event.button.button == SDL_BUTTON_LEFT)
		        leftMouseButtonDown = true;
		case SDL_MOUSEMOTION:
		    if (leftMouseButtonDown)
		    {
		        int mouseX = event.motion.x;
		        int mouseY = event.motion.y;
		        pixels[mouseY * get_width() + mouseX] = 0xffffffff;
		    }
		    break;
                /*any keyboard key pressed*/
                case SDL_KEYDOWN:
                /*exit game*/
                    if(event.key.keysym.sym==SDLK_ESCAPE)
                        quit = true;
                    break;
		case SDL_QUIT:
		    quit = true;
		    break;
		}
	}
}
void Game::render(){
    /** counter in ms \n reset if reach 1000ms */
    static unsigned int timeCounter=0;
    return_value = SDL_UpdateTexture(texture, NULL, pixels, get_width() * sizeof(Uint32));
    assert( return_value == 0);
    
    for(int x=0; x<ILEOBJ; x++) 
            {
            hlp=rand()%8; 
            if(hlp==0) dir=dup;		
            if(hlp==1) dir=ddown;		
            if(hlp==2) dir=dleft;		
            if(hlp==3) dir=dright;		
            if(hlp==4) dir=dupleft;		
            if(hlp==5) dir=dupright;		
            if(hlp==6) dir=ddownleft;		
            if(hlp==7) dir=ddownright;		

            zolnierze[x].move(dir);
            }
    //for (int y=0; y<=YRES-1; y++)
    //for (int x=0; x<=XRES-1; x++) 
//		pixels[y*XRES+x]=rand() *1000;
    //SDL_Delay(10);

    return_value = SDL_RenderClear(renderer);
    assert( return_value == 0);
    return_value = SDL_RenderCopy(renderer, texture, NULL, NULL);
    assert( return_value == 0);

    /** counter for CrAzY ChArAcTeR */
    static unsigned char counter = 0;
    static double FPS=0;
    static int ramka=0;
    static unsigned int last_frame_time, cur_frame_time;
    ramka++; //ilosc klatek    
    last_frame_time = cur_frame_time;
    cur_frame_time = SDL_GetTicks();
    double deltaTime = (double) (cur_frame_time - last_frame_time) / 1000;
    timeCounter += cur_frame_time - last_frame_time;
    // after 1000ms
    if(timeCounter >= 1000 ){

        //calculate fps
        FPS = (ramka);
        // print FPS on terminal
        std::cout<<"FPS: "<<FPS<<"\n";
        // reset time counter 
        timeCounter = 0;
        // CrAzY ChArAcTeR incrementation
        counter++;
        ramka=0;
    }
    
    /** CrAzY ChArAcTeR */

 //   static Sign sign;
 //   sign.show_char(renderer,counter);
    
//    sign.move( sign.get_x()+(rand()%3-1) , sign.get_y()+(rand()%3-1) );
 //   sign.render();
    // destroy CrAzY ChArAcTeR
 //   sign.clear();
  
    // creat stream with fps
    std::ostringstream stream;
    stream<<"fps: "<<FPS;
    
    // creat string with fps
    std::string text = (char *)stream.str().c_str();
    
    /** Create msg to show on screen with info about fps */
/*    Text msg(renderer,0,580,text, text.length());
    // if counter is reseted
    if(timeCounter==0){
        // change msg
       msg.change_msg(&text, text.length());
    }
    //render whole msg
    msg.render();
*/    
    //Update the screen with rendering performed, function SDL_RenderPresent must be on end of frame
    SDL_RenderPresent(renderer);
}

void Game::clean(){
    delete[] pixels;
    SDL_DestroyTexture(texture);
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    TTF_Quit();
    SDL_Quit();
    // write settings on quit
    write_settings();
}

/**
 * 
 * @return the height of the game window
 */
int Game::get_height(){
    return settings_yres;
}
/**
 * 
 * @return the width of the game window
 */
int Game::get_width(){
    return settings_xres;
}

/**
 * read height and width from file settings.txt to settings_xres settings_yres
 */
void Game::read_settings(){
    std::ifstream in("settings.txt");
    if(in.is_open()){
        char ch=0;
        std::string line="";
        unsigned int setx=0;
        unsigned int sety=0;
        while(in.get(ch)){
            // if encountered tag "end of line"
            if(ch=='\n'){
                if(line.find("height=",0)!=std::string::npos){
                    sety=atoi(line.substr(((std::string)"height=").size()+1,line.size()-((std::string)"height=").size()).c_str());
                }else if(line.find("width=",0)!=std::string::npos){
                    setx=atoi(line.substr(((std::string)"width=").size()+1,line.size()-((std::string)"width=").size()).c_str());
                }
                line="";
            }
            line=line+ch;
        }
        in.close();
        if(setx!=0 && sety!=0){
            settings_xres = setx;
            settings_yres = sety;
        }
        //set default values
        else{
            settings_xres = 800;
            settings_yres = 600;
        }
    }
    //set default values
    else{
        settings_xres = 800;
        settings_yres = 600;
    }
    in.close();
//    XRES = settings_xres;
//    YRES = settings_yres;
}
/**
 * overwrite file settings.txt with new height and width, file is created if do not exists
 */
void Game::write_settings(){
    std::ofstream out("settings.txt");
    if(out.is_open()){
        out<<"#settings\n";
        out<<"width=" << settings_xres <<"\n";
        out<<"height="<< settings_yres <<"\n";
    }
    out.close();
}
